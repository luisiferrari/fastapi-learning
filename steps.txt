RUN DEV MODE: 
    fastapi dev .\__init__.py



For any change on DB, if changing columns, tables or whatever, I'm using alembic (pip install alembic) -> https://alembic.sqlalchemy.org/en/latest/
alembic comands:
    after making a change to the model, create a version (something as a commit) -> alembic revision --autogenerate -m "<YOUR MESSAGE HERE>"
    once you checked the new version python file (the one with the upgrade and downgrade functions) -> alembic upgrade head (or downgrade if you want to rollback)

    stoped in :https://youtu.be/TO4aQ3ghFOc?t=23965

#To generate a secret for JWT:
    import secrets      
    secrets.token_hex(16)

docker run -d --name memos  -p 5230:5230 -v ~/.memos:/var/opt/memos neosmemo/memos:stable


Então:
    * Tenho um arquivo utils.py onde crio a lógica de criação do token, verificação do hash da senha, geração do hash da senha e decodificação do token jwt.
    * tenho  um file dependencies que é onde eu herdo a classe do fastapi que me permite pegar os headers e o payload, para pegar o toke, e então checa-lo
    * no serviço de /login, eu checo usando a verificação de hash, se a senha está certa, e se sim, crio o access e refresh token, retornando no payload para o client.

{
  "email": "auth@mail.com",
  "password": "123456"
}

Instalando redis:

docker run -d --name redis-auth -p 6379:6379 redis:7

## Ponto importante de entendimento. 

Quando eu tenho uma função como a de baixo: 

    async def list_books(
        session: AsyncSession = Depends(get_session))

O que acontece é:

1. Chama get_session()
2. Executa até o yield
3. Pega o session
4. Injeta em session: AsyncSession

Isso porque a função get_session, eu faço yield, para que a session morra depois que o call é retornado.

async def get_session():
    Session = sessionmaker(
        bind=engine,
        class_=AsyncSession,
        expire_on_commit=False
    )
    
    async with Session() as session:
        yield session

### Adding permissions:
    Added permission RoleChecker e injetado como dependencia. Observe o arquivo routes de books como eles foram injetados, uma maneira diferente de como tenho feito até então.

## Dockerização:
build da imagem:
    docker build -t minha-app-books .
subir um container:
    docker run -d --name app-container  -p 8000:8000  --add-host=host.docker.internal:host-gateway  --env-file ./src/.env  minha-app-books